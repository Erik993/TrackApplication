using Bogus;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using System;
using System.Collections.Generic;
using System.Text;
using TestProject1.EmployeeTests.FakeClasses;
using TrackApplication.Services;
using TrackApplicationCore.States;
using TrackApplicationCore.ViewModels;
using TrackApplicationData.Models;

namespace TestProject1.EmployeeTests;


// EmployeeViewModel is tested. FakeEmployeerepository is used, instead of real one that works with database
// DBContext is replaced with List in Fake repository class.
public class EmployeeTests
{

    //Test nr 1
    //when craeting viewmodel instance, elements from repository should be loaded into state
    [Fact]
    public void ConstructorLoadsEmployees()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //add 2 elements to the repositorys list
        fakerepo.Employees.Add(new Employee("John", "john@test.com", true));
        fakerepo.Employees.Add(new Employee("Anna", "anna@test.com", true));

        //act
        //EmployeeViewModel constructor has LoadEmployees() in it
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //assert
        Assert.Equal(2, state.Employees.Count);
        Assert.Equal("John", state.Employees[0].UserName);
        Assert.Equal("Anna", state.Employees[1].UserName);
    }


    //Test nr 2
    //if state has > 0 elements, they are cleared before new ones from repository are added into state
    [Fact]
    public async Task ClearStateBeforeLoadNewElements()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //add 2 elements to the repository list
        fakerepo.Employees.Add(new Employee("John", "john@test.com", true));
        fakerepo.Employees.Add(new Employee("Anna", "anna@test.com", true));

        //create empty viewModel. as the constructor has LoadEmployees(), elements are loaded to the state.
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //clear repository
        //without clear, the same repositorys elements will be loaded to the state for the second time, but we need to substitute them
        fakerepo.Employees.Clear();

        //act
        //add new elements to the repository
        fakerepo.Employees.Add(new Employee("Henry", "henry@test.com", true));
        fakerepo.Employees.Add(new Employee("Bob", "bob@test.com", true));
        fakerepo.Employees.Add(new Employee("Anna", "anna@test.com", true));
        await viewModel.LoadEmployees();

        //assert
        //check how many elements in the state and the sequence
        Assert.Equal(3, viewModel.Employees.Count);
        Assert.Equal("Henry", viewModel.Employees[0].UserName);
        Assert.Equal("Bob", viewModel.Employees[1].UserName);
        Assert.Equal("Anna", viewModel.Employees[2].UserName);
    }

    //Test nr 3
    //Elements with valid inputs should be added
    //Test AddEmployeeCommand, that is generated by RelayCommand flag
    [Fact]
    public async Task AddNewEmployeesWithValidInput()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //act
        //add 2 elements
        viewModel.NewUserName = "John";
        viewModel.NewEmail = "john@test.com";
        viewModel.NewIsActive = false;

        //Execute should be used to call command, because AddEmployeeCommand is a command, not method 
        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        viewModel.NewUserName = "Anna";
        viewModel.NewEmail = "anna@test.com";
        viewModel.NewIsActive = true;

        //Execute should be used to call command, because AddEmployeeCommand is a command, not method 
        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        //assert
        Assert.Equal(2, viewModel.Employees.Count);

        Assert.Equal("John", viewModel.Employees[0].UserName);
        Assert.Equal("john@test.com", viewModel.Employees[0].Email);
        Assert.False(viewModel.Employees[0].IsActive);

        Assert.Equal("Anna", viewModel.Employees[1].UserName);
        Assert.Equal("anna@test.com", viewModel.Employees[1].Email);
        Assert.True(viewModel.Employees[1].IsActive);
    }

    //Test nr 4
    //Elements with valid inputs should be added
    //Test AddEmployeeCommand, that is generated by RelayCommand flag
    [Fact]
    public async Task AddNewEmployeesButDontExecuteAddCommand()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //act
        //add 2 elements
        viewModel.NewUserName = "John";
        viewModel.NewEmail = "john@test.com";
        viewModel.NewIsActive = false;

        //Execute should be used to call command, because AddEmployeeCommand is a command, not method 
        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        //add an element but dont execute add command 
        viewModel.NewUserName = "Anna";
        viewModel.NewEmail = "anna@test.com";
        viewModel.NewIsActive = true;

        //assert
        //collection should contain only 1 element
        Assert.Single(viewModel.Employees);

        Assert.Equal("John", viewModel.Employees[0].UserName);
        Assert.Equal("john@test.com", viewModel.Employees[0].Email);
        Assert.False(viewModel.Employees[0].IsActive);
    }


    //Test nr 5
    //Check input validation, Employee with empty username should not be added to viewmodel
    //Test AddEmployeeCommand, that is generated by RelayCommand flag
    [Fact]
    public async Task AddNewEmployeeDoesNotAcceptEmptyUserName()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();
        
        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        viewModel.NewUserName = "";
        viewModel.NewEmail = "a";

        //Execute should be used to call command, because AddEmployeeCommand is a command, not method 
        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        //assert
        //check how many elements in the state and the sequence
        Assert.Empty(viewModel.Employees);
    }


    //Test nr 6
    //Check input validation, Employee with whitespace in username should not be added to viewmodel
    //Test AddEmployeeCommand, that is generated by RelayCommand flag
    //Test fails, because it is not checked if input is whitespace and element with whitespace in name is being created
    [Fact]
    public async Task AddNewEmployeeDoesNotAcceptWhiteSpaceInUserName()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        viewModel.NewUserName = " ";
        viewModel.NewEmail = "a";

        //Execute should be used to call command, because AddEmployeeCommand is a command, not method 
        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        //assert
        //check how many elements in the state and the sequence
        Assert.Empty(viewModel.Employees);
    }


    //Test nr 6
    //Check input validation, Employee with empty email should not be added to viewmodel
    //Test AddEmployeeCommand, that is generated by RelayCommand flag
    [Fact]
    public async Task AddNewEmployeeDoesNotAcceptEmptyUserEmail()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);
        viewModel.NewUserName = "Erik";
        viewModel.NewEmail = "";

        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        //assert
        //check how many elements in viewmodel and repository
        Assert.Empty(viewModel.Employees);
        Assert.Empty(fakerepo.Employees);
    }


    //Test nr 7
    //Check input validation, Employee with empty email should not be added to viewmodel
    //Test AddEmployeeCommand, that is generated by RelayCommand flag
    //Test fails, because it is not checked if input is whitespace and element with whitespace in email is being created
    [Fact]
    public async Task AddNewEmployeeDoesNotAcceptWhiteSpaceInUserEmail()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);
        viewModel.NewUserName = "Erik";
        viewModel.NewEmail = " ";

        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        //assert
        //check how many elements in viewmodel and repository
        Assert.Empty(viewModel.Employees);
        Assert.Empty(fakerepo.Employees);
    }

    //Test nr 8
    //Check input validation, Employee with empty email should not be added to viewmodel
    //Test AddEmployeeCommand, that is generated by RelayCommand flag
    //test fails, because no email regex validation
    [Fact]
    public async Task AddNewEmployeeDoesNotAcceptUserEmailWithoutAtSign()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);
        viewModel.NewUserName = "Erik";
        viewModel.NewEmail = "w";

        //without passing null, command cant be executed
        await viewModel.AddEmployeeCommand.ExecuteAsync(null);

        //assert
        //check how many elements in viewmodel and repository
        Assert.Empty(viewModel.Employees);
        Assert.Empty(fakerepo.Employees);
    }



    //Test nr 9
    //Test DeleteEmployee method and generated by RelayCommand flag - DeleteEmployeeCommand
    [Fact]
    public async Task IsEmployeeDeleted()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //add 1 element to the repository list
        fakerepo.Employees.Add(new Employee("a", "anna@test.com", true));

        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //select employee
        var employee = viewModel.Employees[0];

        //Execute is used in pair with Command type, to use related method
        //delete selected employee
        await viewModel.DeleteEmployeeCommand.ExecuteAsync(employee);

        //assert
        //should be empty
        Assert.Empty(viewModel.Employees);
    }


    //Test nr 10
    //Test DeleteEmployee method and generated by RelayCommand flag - DeleteEmployeeCommand
    //selected element is deleted from 3 existing
    [Fact]
    public async Task IsOneParticularEmployeeDeletedFromManyExisting()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //add 3 elements to the repository list
        fakerepo.Employees.Add(new Employee("a", "a@test.com", true));
        fakerepo.Employees.Add(new Employee("b", "b@test.com", true));
        fakerepo.Employees.Add(new Employee("c", "c@test.com", true));

        //create new viewmodel, whose constructor takes a repository with elements
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //select 1 employee with index 1
        var employee = viewModel.Employees[1];

        //Execute is used in pair with Command type, to use related method
        //delete selected employee
        await viewModel.DeleteEmployeeCommand.ExecuteAsync(employee);

        //assert
        //Employee count should be 2, and left are "a" and "c" elements
        Assert.Equal(2, viewModel.Employees.Count);
        Assert.Equal("a", viewModel.Employees[0].UserName);
        Assert.Equal("c", viewModel.Employees[1].UserName);
    }


    //Test nr 11
    //Employee should be updated
    [Fact]
    public async Task IsEmployeeUpdated()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //add 1 element to the repository list
        fakerepo.Employees.Add(new Employee("a", "a@test.com", true));

        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //select employee
        var employee = viewModel.Employees[0];

        //update employee
        viewModel.SelectedEmployee = employee;
        viewModel.EditUserName = "b";
        viewModel.EditEmail = "b@test.com";

        //Execute is used in pair with Command type, to use related method
        //update selected employee
        await viewModel.UpdateEmployeeCommand.ExecuteAsync(null);

        //assert
        Assert.Equal("b", viewModel.Employees[0].UserName);
        Assert.Equal("b@test.com", viewModel.Employees[0].Email);
    }


    //Test nr 12
    //Dont select particular employee but change name and email fields
    [Fact]
    public async Task UnselectedEmployeeShouldNotBeUpdated()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //add 1 element to the repository list
        fakerepo.Employees.Add(new Employee("a", "a@test.com", true));

        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //select employee
        var employee = viewModel.Employees[0];

        //dont select particular employee, but add a new values to edit fields
        //viewModel.SelectedEmployee = employee;
        viewModel.EditUserName = "b";
        viewModel.EditEmail = "b@test.com";

        //Execute is used in pair with Command type, to use related method
        //update selected employee
        await viewModel.UpdateEmployeeCommand.ExecuteAsync(null);

        //assert
        Assert.Equal("a", viewModel.Employees[0].UserName);
        Assert.Equal("a@test.com", viewModel.Employees[0].Email);
    }


    //test nr 13
    //trying to edit employee, edit page should load existing employees data into fields, that can be changed later
    //check that edit fields are fille
    //test LoadEmployeeForEdit method
    [Fact]
    public async Task IsEmployeeDataLoadedForEdit()
    {
        //arrange
        var fakerepo = new FakeEmployeeRepository();
        var state = new EmployeeState();
        var navigation = new NavigationService();
        var alert = new AlertService();

        //act
        //add 1 element to the repository list
        fakerepo.Employees.Add(new Employee("a", "a@test.com", false));

        //create new viewmodel, whose constructor takes a repository with element
        var viewModel = new EmployeeViewModel(fakerepo, state, navigation, alert);

        //select employee
        var employee = viewModel.Employees[0];

        //Execute is used in pair with Command type, to use related method
        //update selected employee
        await viewModel.LoadEmployeeForEdit(employee.UserId);

        //assert
        Assert.NotNull(viewModel.SelectedEmployee);
        Assert.Equal("a", viewModel.EditUserName);
        Assert.Equal("a@test.com", viewModel.EditEmail);
        Assert.False(viewModel.EditIsActive);
    }

}

